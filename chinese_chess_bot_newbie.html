<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>HTMLä¸­å›½è±¡æ£‹ | AIå¯¹æˆ˜ç‰ˆ | å·¦å³å¸ƒå±€</title>
    <style>
        :root {
            --cell-size: 50px;
            --piece-size: calc(var(--cell-size) * 0.90);
            --margin: calc(var(--cell-size) / 2);
            --board-width: calc(var(--cell-size) * 9);
            --board-height: calc(var(--cell-size) * 10);
            --body-bg: #daccb4;
            --board-bg: #e6c895;
            --board-line-color: #6a4b3a;
            --river-bg: rgba(106, 75, 58, 0.08);
            --river-color: #a07e64;
            --piece-bg: #fdfcf5;
            --red-color: #d53f3f;
            --black-color: #2c2c2c;
            --select-color: rgba(70, 130, 180, 1);
            --capture-color: rgba(255, 100, 0, 1);
            --dot-color: rgba(40, 160, 80, 0.9);
            --last-move-color: rgba(60, 60, 200, 0.7);
            --info-check-color: #FF4500;
            --info-ai-color: #4682B4;
            /* SteelBlue */
            --piece-font: 'Kaiti', 'STKaiti', 'Kai', 'SimSun', serif;
            --board-border: 4px;
            --panel-width: 190px; /* é¢æ¿å®½åº¦ */
            --layout-breakpoint: 860px; /* å¸ƒå±€åˆ‡æ¢æ–­ç‚¹ */
            --layout-gap: 20px; /* é—´è· */
        }

        html,
        body {
            height: 100%;
            margin: 0;
            overflow-x: hidden;
            overflow-y: auto;
             padding: 0;
        }

        body {
            font-family: 'Helvetica Neue', Arial, 'PingFang SC', 'Hiragino Sans GB', 'Microsoft YaHei', sans-serif;
            display: flex;
            align-items: center; /* å‚ç›´å±…ä¸­ wrapper */
            justify-content: center; /* æ°´å¹³å±…ä¸­ wrapper */
            background-color: var(--body-bg);
            user-select: none;
            box-sizing: border-box;
            width: 100%;
            min-height: 100%;
             padding-top: 15px; /* æ•´ä½“padding */
             padding-bottom: 15px;
        }
        
       /* ++++ æ–°å¢ä¸»å®¹å™¨ ++++ */
        #game-wrapper {
            display: flex;
            flex-direction: row; /* é»˜è®¤å·¦å³å¸ƒå±€ */
            align-items: center; /* æ£‹ç›˜å’Œé¢æ¿å‚ç›´å±…ä¸­å¯¹é½ */
            justify-content: center;
            gap: var(--layout-gap);
            padding: 10px;
            box-sizing: border-box;
             flex-wrap: nowrap;
        }

        /* ++++ ä¿¡æ¯/æ§åˆ¶é¢æ¿ (åŸ main-container) ++++ */
        #info-panel {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            width: var(--panel-width); /* å›ºå®šå®½åº¦ */
            padding: 10px;
            flex-shrink: 0; /* é˜²æ­¢è¢«å‹ç¼© */
            box-sizing: border-box;
            background-color: rgba(255,255,255, 0.15);
            border-radius: 8px;
             border: 1px solid rgba(0,0,0,0.1);
             min-height: 200px;
        }

        .button-row {
            display: flex;
            flex-direction: column; /* å·¦å³å¸ƒå±€æ—¶ï¼ŒæŒ‰é’®å‚ç›´æ’åˆ— */
            gap: 10px;
            margin-top: 15px;
             width: 90%;
        }

        h1 {
            margin-top: 5px;
            margin-bottom: 10px;
            text-align: center;
            color: #444;
            font-size: 1.3em;
        }

        #info {
            font-size: 0.95em;
            font-weight: bold;
            min-height: 1.5em;
            color: #333;
            width: 100%; /* å¡«å……é¢æ¿ */
            text-align: center;
            padding: 6px 8px;
            background-color: rgba(255, 255, 255, 0.4);
            border-radius: 4px;
            margin-bottom: 0; /* è°ƒæ•´é—´éš” */
            transition: color 0.3s, background-color 0.3s;
             box-sizing: border-box;
              min-height: 50px;
              display: flex; /*ç”¨äºå†…å®¹å±…ä¸­*/
              align-items: center;
               justify-content: center;
        }

        .info-check {
            background-color: rgba(255, 69, 0, 0.25) !important;
            color: var(--info-check-color) !important;
        }
         .info-ai {
             background-color: rgba(70, 130, 180, 0.25) !important;
             color: var(--info-ai-color) !important;
         }

        .game-button {
            padding: 8px 12px;
            font-size: 0.9em;
            cursor: pointer;
            background-color: var(--board-line-color);
            color: white;
            border: none;
            border-radius: 4px;
            box-shadow: 1px 2px 4px rgba(0, 0, 0, 0.3);
            transition: background-color 0.2s, transform 0.2s;
             width: 100%; /* å¡«å……æŒ‰é’®è¡Œ */
              text-align: center;
        }

        .game-button:hover {
            background-color: #8a6b5a;
        }

        .game-button:active {
            transform: scale(0.98);
        }

        #fullscreen-button {
            position: fixed;
            top: 8px;
            right: 10px;
            z-index: 1000;
            padding: 0;
            width: 32px;
            height: 30px;
            text-align: center;
            font-size: 1.1em;
            cursor: pointer;
            background-color: rgba(80, 80, 80, 0.4);
            color: white;
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 4px;
            opacity: 0.7;
            transition: opacity 0.2s, background-color 0.2s;
            line-height: 30px; /* å‚ç›´å±…ä¸­ */
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.2);
            display: none;
             box-sizing: border-box;
        }

        #fullscreen-button:hover {
            opacity: 1;
            background-color: rgba(100, 100, 100, 0.8);
        }

        #fullscreen-button:active {
            transform: scale(0.95);
        }

        #board-container {
            position: relative;
            width: var(--board-width);
            height: var(--board-height);
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
            border: var(--board-border) solid var(--board-line-color);
            box-sizing: content-box;
            touch-action: none;
           /* margin-bottom: 15px; */ /* ç§»é™¤ */
            background-color: var(--board-line-color);
             flex-shrink: 0; /* é˜²æ­¢è¢«å‹ç¼© */
        }

        #board-canvas {
            position: absolute; top: 0; left: 0; z-index: 1;
            pointer-events: none;
            display: block;
            background-color: transparent;
        }

        #pieces-layer {
            position: absolute; top: 0; left: 0;
            width: 100%; height: 100%; z-index: 2;
        }

        .piece,
        .highlight-dot,
        .last-move-indicator {
            position: absolute;
            transform: translate(-50%, -50%);
            box-sizing: border-box;
        }

        .piece {
            width: var(--piece-size); height: var(--piece-size); border-radius: 50%;
            display: flex; align-items: center; justify-content: center;
            font-size: calc(var(--piece-size) * 0.68);
            font-weight: bold;
            font-family: var(--piece-font);
            line-height: 1; cursor: pointer;
            background-color: var(--piece-bg);
            background-image: radial-gradient(circle at 35% 35%, #ffffff, var(--piece-bg) 70%);
            border: calc(var(--cell-size) * 0.02) solid;
            box-shadow: 1px 1px 3px rgba(0, 0, 0, 0.35),
                inset 0 0 0 calc(var(--cell-size) * 0.04) var(--piece-bg),
                inset 0 0 0 calc(var(--cell-size) * 0.065) var(--current-color);
            z-index: 10;
            transition: box-shadow 0.15s ease-out, transform 0.15s ease-out;
            --current-color: grey;
        }

        .piece.red { color: var(--red-color); border-color: var(--red-color); --current-color: var(--red-color); }
        .piece.black { color: var(--black-color); border-color: var(--black-color); --current-color: var(--black-color); }
        .piece.selected {
            box-shadow: 0 0 calc(var(--cell-size) * 0.18) calc(var(--cell-size) * 0.07) var(--select-color),
                1px 2px 4px rgba(0, 0, 0, 0.2),
                inset 0 0 0 calc(var(--cell-size) * 0.04) var(--piece-bg),
                inset 0 0 0 calc(var(--cell-size) * 0.065) var(--current-color);
            transform: translate(-50%, -50%) scale(1.03);
            z-index: 12;
        }

        .highlight-dot {
            width: calc(var(--piece-size) * 0.25); height: calc(var(--piece-size) * 0.25);
            background-color: var(--dot-color); border-radius: 50%; border: none; cursor: pointer; z-index: 5;
            box-shadow: 0 0 calc(var(--cell-size) * 0.07) calc(var(--cell-size) * 0.01) var(--dot-color);
        }

        .piece.possible-capture {
            box-shadow: 0 0 calc(var(--cell-size) * 0.18) calc(var(--cell-size) * 0.07) var(--capture-color),
                1px 2px 3px rgba(0, 0, 0, 0.2),
                inset 0 0 0 calc(var(--cell-size) * 0.04) var(--piece-bg),
                inset 0 0 0 calc(var(--cell-size) * 0.065) var(--current-color);
            transform: translate(-50%, -50%) scale(1.01);
            z-index: 11;
        }

        .last-move-indicator {
            width: calc(var(--piece-size) * 1.05); height: calc(var(--piece-size) * 1.05);
            border: calc(var(--cell-size) * 0.03) dashed var(--last-move-color);
            border-radius: 50%;
            z-index: 4; pointer-events: none; opacity: 0.9;
            box-shadow: 0 0 3px var(--last-move-color);
        }

        .last-move-indicator.to-indicator {
            border-style: solid; z-index: 11; opacity: 0.7;
        }
         
        /* ++++ å“åº”å¼æ–­ç‚¹ï¼šåˆ‡æ¢ä¸ºä¸Šä¸‹å¸ƒå±€ ++++ */
         @media (max-width: 860px) { /* ä½¿ç”¨å˜é‡ var(--layout-breakpoint) åœ¨æŸäº›æµè§ˆå™¨æ”¯æŒä¸å¥½ */
            #game-wrapper {
                 flex-direction: column; /* æ”¹ä¸ºä¸Šä¸‹å¸ƒå±€ */
                 align-items: center;
                  padding-top: 30px; /* ä¸ºå…¨å±æŒ‰é’®ç•™ç©ºé—´ */
            }
             #info-panel {
                  width: auto; /* å®½åº¦è‡ªé€‚åº” */
                  max-width: 500px;
                  min-height: auto;
                  padding: 5px 15px;
                   order: 1; /* ä¿¡æ¯åŒºåœ¨ä¸Š */
             }
              #board-container {
                   order: 2; /* æ£‹ç›˜åœ¨ä¸‹ */
                   margin-bottom: 15px;
              }
              .button-row {
                 flex-direction: row; /* ä¸Šä¸‹å¸ƒå±€æ—¶ï¼ŒæŒ‰é’®æ°´å¹³æ’åˆ— */
                 gap: 15px;
                 margin-top: 8px;
                  width: auto;
              }
               .game-button {
                 width: auto; /* æŒ‰é’®å®½åº¦è‡ªé€‚åº” */
                 padding: 6px 15px;
                 font-size: 0.85em;
               }
               h1 { font-size: 1.2em; margin-bottom: 5px;}
               #info { margin-bottom: 0; padding: 4px 10px; min-height: 1.8em;}
         }


        body:-webkit-full-screen { background-color: var(--body-bg); width: 100%; height: 100%; overflow: hidden; padding: 0;}
        body:-moz-full-screen { background-color: var(--body-bg); overflow: hidden;  padding: 0;}
        body:fullscreen { background-color: var(--body-bg); overflow: hidden;  padding: 0; }
        /* ç¡®ä¿å…¨å±æ—¶wrapperä¹Ÿèƒ½å±…ä¸­ */
         #game-wrapper:fullscreen,
         #game-wrapper:-webkit-full-screen,
          #game-wrapper:-moz-full-screen {
             width: 100%;
             height: 100%;
         }


    </style>
</head>

<body>
    <button id="fullscreen-button" title="åˆ‡æ¢å…¨å±">â›¶</button>

    <!-- ++++ æ–°å¢ wrapper ++++ -->
    <div id="game-wrapper">
         <!-- ++++ é‡å‘½å info-panel ++++ -->
        <div id="info-panel">
            <h1>ä¸­å›½è±¡æ£‹</h1>
            <div id="info">å‡†å¤‡å¼€å§‹</div>
            <div class="button-row">
                <button id="mode-button" class="game-button">æ¨¡å¼: äºº-äºº</button>
                <button id="reset-button" class="game-button">æ–° å¼€ å±€</button>
                <button id="undo-button" class="game-button">æ‚” æ£‹</button>
            </div>
        </div>

        <div id="board-container">
            <canvas id="board-canvas"></canvas>
            <div id="pieces-layer"></div>
        </div>
         
    </div> <!-- end game-wrapper -->


    <script>
        // ======== AI CONFIG ========
        const SEARCH_DEPTH = 4; // æœç´¢æ·±åº¦: 2=å¿«ä½†å¼±, 3=ä¸­ç­‰, 4=æ…¢ä½†è¾ƒå¼º(å¯èƒ½å¡é¡¿10s+), 5=éå¸¸æ…¢
        const QUIESCENCE_DEPTH = 4; // é™æ€æœç´¢æ·±åº¦
        const AI_DELAY = 150; // AIå¼€å§‹æ€è€ƒå‰çš„å»¶è¿Ÿmsï¼Œç¡®ä¿äººç±»è½å­ç”»é¢åˆ·æ–°
        
        // å¼€å±€é˜¶æ®µæ£‹å­ä»·å€¼ï¼ˆå‰10å›åˆï¼‰
        const OPENING_VALUES = {
            'G': 20000,
            'R': 1000,
            'C': 600,
            'H': 500,
            'E': 100,
            'A': 100,
            'S': 100, // é»˜è®¤å€¼ï¼Œå…·ä½“æ ¹æ®ä½ç½®è°ƒæ•´
        };
        
        // ä¸­å±€é˜¶æ®µæ£‹å­ä»·å€¼ï¼ˆåŸå§‹å€¼ï¼‰
        const MIDGAME_VALUES = {
            'G': 20000,
            'R': 900,
            'C': 450,
            'H': 400,
            'E': 150,
            'A': 150,
            'S': 100,
        };
        
        // æ®‹å±€é˜¶æ®µæ£‹å­ä»·å€¼ï¼ˆåŒæ–¹å¤§å­éƒ½å°‘äº3ä¸ªï¼‰
        const ENDGAME_VALUES = {
            'G': 20000,
            'R': 1500,
            'C': 550,
            'H': 700,
            'E': 250,
            'A': 250,
            'S': 150,
        };
        
        const SOLDIER_CROSS_RIVER_BONUS = 80;
        
        // Position value tables for each piece type
        const POSITION_VALUES = {
            'R': [ // è½¦
                [14, 14, 12, 18, 16, 18, 12, 14, 14],
                [16, 20, 18, 24, 26, 24, 18, 20, 16],
                [12, 12, 12, 18, 18, 18, 12, 12, 12],
                [12, 18, 16, 22, 22, 22, 16, 18, 12],
                [12, 14, 12, 18, 18, 18, 12, 14, 12],
                [12, 16, 14, 20, 20, 20, 14, 16, 12],
                [6, 10,  8, 14, 14, 14,  8, 10,  6],
                [4,  8,  6, 14, 12, 14,  6,  8,  4],
                [8,  4,  8, 16,  8, 16,  8,  4,  8],
                [-2, 10,  6, 14, 12, 14,  6, 10, -2]
            ],
            'H': [ // é©¬
                [4,  8, 16,  12, 4, 12, 16,  8,  4],
                [4, 10, 28,  16, 8, 16, 28, 10,  4],
                [12, 14, 16, 20, 18, 20, 16, 14, 12],
                [8, 24, 18, 24, 20, 24, 18, 24,  8],
                [6, 16, 14, 18, 16, 18, 14, 16,  6],
                [4, 12, 16, 14, 12, 14, 16, 12,  4],
                [2,  6,  8,  6, 10,  6,  8,  6,  2],
                [4,  2,  8,  8,  4,  8,  8,  2,  4],
                [0,  2,  4,  4, -2,  4,  4,  2,  0],
                [0, -4,  0,  0,  0,  0,  0, -4,  0]
            ],
            'C': [ // ç‚®
                [6,  4,  0, -10, -12, -10,  0,  4,  6],
                [2,  2,  0,  -4, -14,  -4,  0,  2,  2],
                [2,  2,  0, -10,  -8, -10,  0,  2,  2],
                [0,  0, -2,   4,  10,   4, -2,  0,  0],
                [0,  0,  0,   2,   8,   2,  0,  0,  0],
                [-2, 0,  4,   2,   6,   2,  4,  0, -2],
                [0,  0,  0,   2,   4,   2,  0,  0,  0],
                [4,  0,  8,   6,  10,   6,  8,  0,  4],
                [0,  2,  4,   6,   6,   6,  4,  2,  0],
                [0,  0,  2,   6,   6,   6,  2,  0,  0]
            ],
            'S': [ // å…µ/å’
                [0,  3,  6,  9, 12,  9,  6,  3, 0],
                [18, 36, 56, 80, 120, 80, 56, 36, 18],
                [14, 26, 42, 60, 80, 60, 42, 26, 14],
                [10, 20, 30, 34, 40, 34, 30, 20, 10],
                [6, 12, 18, 18, 20, 18, 18, 12, 6],
                [2,  0,  8,  0,  8,  0,  8,  0, 2],
                [0,  0, -2,  0,  4,  0, -2,  0, 0],
                [0,  0,  0,  0,  0,  0,  0,  0, 0],
                [0,  0,  0,  0,  0,  0,  0,  0, 0],
                [0,  0,  0,  0,  0,  0,  0,  0, 0]
            ],
            'E': [ // ç›¸/è±¡
                [0, 0, 0, 0, 0, 0, 0, 0, 0],
                [0, 0, 0, 0, 0, 0, 0, 0, 0],
                [0, 0, 0, 0, 0, 0, 0, 0, 0],
                [0, 0, 0, 0, 0, 0, 0, 0, 0],
                [0, 0, 0, 0, 0, 0, 0, 0, 0],
                [0, 0, 20, 0, 0, 0, 20, 0, 0],
                [0, 0, 0, 0, 0, 0, 0, 0, 0],
                [18, 0, 0, 0, 23, 0, 0, 0, 18],
                [0, 0, 0, 0, 0, 0, 0, 0, 0],
                [0, 0, 20, 0, 0, 0, 20, 0, 0]
            ],
            'A': [ // ä»•/å£«
                [0, 0, 0, 0, 0, 0, 0, 0, 0],
                [0, 0, 0, 0, 0, 0, 0, 0, 0],
                [0, 0, 0, 0, 0, 0, 0, 0, 0],
                [0, 0, 0, 0, 0, 0, 0, 0, 0],
                [0, 0, 0, 0, 0, 0, 0, 0, 0],
                [0, 0, 0, 0, 0, 0, 0, 0, 0],
                [0, 0, 0, 0, 0, 0, 0, 0, 0],
                [0, 0, 0, 20, 0, 20, 0, 0, 0],
                [0, 0, 0, 0, 23, 0, 0, 0, 0],
                [0, 0, 0, 20, 0, 20, 0, 0, 0]
            ],
            'G': [ // å°†/å¸…
                [0, 0, 0, 0, 0, 0, 0, 0, 0],
                [0, 0, 0, 0, 0, 0, 0, 0, 0],
                [0, 0, 0, 0, 0, 0, 0, 0, 0],
                [0, 0, 0, 0, 0, 0, 0, 0, 0],
                [0, 0, 0, 0, 0, 0, 0, 0, 0],
                [0, 0, 0, 0, 0, 0, 0, 0, 0],
                [0, 0, 0, 0, 0, 0, 0, 0, 0],
                [0, 0, 0, 8, 8, 8, 0, 0, 0],
                [0, 0, 0, 8, 8, 8, 0, 0, 0],
                [0, 0, 0, 15, 20, 15, 0, 0, 0]
            ]
        };
        
        
        let moveHistory = [];
        let killerMoves = Array(10).fill(null).map(() => [null, null]);
        let historyTable = {};
        // ======== END AI CONFIG ========

        const COLS = 9;
        const ROWS = 10;
        const gameWrapper = document.getElementById('game-wrapper'); // +++
        const boardContainer = document.getElementById('board-container');
        const infoPanel = document.getElementById('info-panel'); // Renamed
        const canvas = document.getElementById('board-canvas');
        const ctx = canvas.getContext('2d');
        const piecesLayer = document.getElementById('pieces-layer');
        const infoDiv = document.getElementById('info');
        const resetButton = document.getElementById('reset-button');
        const modeButton = document.getElementById('mode-button');
        const undoButton = document.getElementById('undo-button');
        const fullscreenButton = document.getElementById('fullscreen-button');
        const rootStyle = getComputedStyle(document.documentElement);
        const PIECE_FONT_FAMILY = rootStyle.getPropertyValue('--piece-font').trim();
        const RIVER_COLOR = rootStyle.getPropertyValue('--river-color').trim();
        const RIVER_BG = rootStyle.getPropertyValue('--river-bg').trim();
        const BOARD_LINE_COLOR = rootStyle.getPropertyValue('--board-line-color').trim();
        const BOARD_BG_COLOR = rootStyle.getPropertyValue('--board-bg').trim();
        const RED_COLOR = rootStyle.getPropertyValue('--red-color').trim();
        const BLACK_COLOR = rootStyle.getPropertyValue('--black-color').trim();
        const INFO_CHECK_COLOR = rootStyle.getPropertyValue('--info-check-color').trim();
         const INFO_AI_COLOR = rootStyle.getPropertyValue('--info-ai-color').trim();
        const BOARD_BORDER_WIDTH = parseInt(rootStyle.getPropertyValue('--board-border')) || 4;
        const LAYOUT_GAP = parseInt(rootStyle.getPropertyValue('--layout-gap')) || 20; // +++

        let cellSize, margin, canvasWidth, canvasHeight;
        let resizeDebounceTimer;
        const dpr = window.devicePixelRatio || 1;

        const INITIAL_BOARD = [['bR', 'bH', 'bE', 'bA', 'bG', 'bA', 'bE', 'bH', 'bR'], [null, null, null, null, null, null, null, null, null], [null, 'bC', null, null, null, null, null, 'bC', null], ['bS', null, 'bS', null, 'bS', null, 'bS', null, 'bS'], [null, null, null, null, null, null, null, null, null], [null, null, null, null, null, null, null, null, null], ['rS', null, 'rS', null, 'rS', null, 'rS', null, 'rS'], [null, 'rC', null, null, null, null, null, 'rC', null], [null, null, null, null, null, null, null, null, null], ['rR', 'rH', 'rE', 'rA', 'rG', 'rA', 'rE', 'rH', 'rR'],];
        const PIECE_MAP = { 'rG': 'å¸…', 'rA': 'ä»•', 'rE': 'ç›¸', 'rH': 'é©¬', 'rR': 'è½¦', 'rC': 'ç‚®', 'rS': 'å…µ', 'bG': 'å°†', 'bA': 'å£«', 'bE': 'è±¡', 'bH': 'é©¬', 'bR': 'è½¦', 'bC': 'ç ²', 'bS': 'å’', };
        const COLOR_MAP = { 'r': 'red', 'b': 'black' };
        const COLOR_NAME = { 'red': 'çº¢æ–¹', 'black': 'é»‘æ–¹' };

        let boardData = [];
        let currentPlayer = 'red';
        let selectedPiece = null;
        let possibleMoves = [];
        let isGameOver = false;
        let redGeneralPos = { x: 4, y: 9 };
        let blackGeneralPos = { x: 4, y: 0 };
        let lastMove = null;
        let gameMode = 'PVP'; // 'PVP', 'PVAI', 'AIVP'
        let aiColor = 'black'; //
        let isAiThinking = false; //
        let gameStateHistory = []; // æ¸¸æˆçŠ¶æ€å†å²è®°å½•ï¼Œç”¨äºæ‚”æ£‹
        let isBoardFlipped = false; // æ£‹ç›˜æ˜¯å¦ç¿»è½¬

        const getPiece = (x, y, board = boardData) => (isValidCoord(x, y) ? board[y]?.[x] : null);
        const isEmpty = (x, y, board = boardData) => (isValidCoord(x, y) && board[y]?.[x] === null);
        const isEnemy = (x, y, color, board = boardData) => { const piece = getPiece(x, y, board); return piece && piece[0] !== color[0]; };
        const isAlly = (x, y, color, board = boardData) => { const piece = getPiece(x, y, board); return piece && piece[0] === color[0]; };
        const isValidCoord = (x, y) => x >= 0 && x < COLS && y >= 0 && y < ROWS;
        const isRedPalace = (x, y) => x >= 3 && x <= 5 && y >= 7 && y <= 9;
        const isBlackPalace = (x, y) => x >= 3 && x <= 5 && y >= 0 && y <= 2;
        const isRedSide = (y) => y >= 5;
        const isBlackSide = (y) => y <= 4;
        const copyBoard = (board) => board.map(row => [...row]);
        
        // è·å–è§†è§‰åæ ‡ï¼ˆè€ƒè™‘æ£‹ç›˜ç¿»è½¬ï¼‰
        const getVisualCoords = (x, y) => {
            if (isBoardFlipped) {
                return { x: 8 - x, y: 9 - y };
            }
            return { x, y };
        };
        
        // ä»è§†è§‰åæ ‡è½¬æ¢ä¸ºé€»è¾‘åæ ‡
        const getLogicalCoords = (visualX, visualY) => {
            if (isBoardFlipped) {
                return { x: 8 - visualX, y: 9 - visualY };
            }
            return { x: visualX, y: visualY };
        };

        // ++++ æ ¸å¿ƒä¿®æ”¹ï¼šæ ¹æ®å¸ƒå±€è®¡ç®—å°ºå¯¸ ++++
        function setupBoardDimensions() {
            // å¼ºåˆ¶æµè§ˆå™¨è®¡ç®—å½“å‰æ ·å¼å’Œå°ºå¯¸
            const wrapperStyle = window.getComputedStyle(gameWrapper);
            const panelRect = infoPanel.getBoundingClientRect();
            const bodyRect = document.body.getBoundingClientRect();
           
            const currentWidth = window.innerWidth;
            const currentHeight = window.innerHeight;

            // çª—å£è¾¹ç¼˜çš„æœ€å°ç•™ç™½
            const paddingWindowHorizontal = 20;
            const paddingWindowVertical = 40; // è€ƒè™‘å…¨å±æŒ‰é’®

            let availableWidth;
            let availableHeight;
           
            // åˆ¤æ–­å½“å‰å¸ƒå±€æ¨¡å¼
            if (wrapperStyle.flexDirection === 'column') {
                 // --- ä¸Šä¸‹å¸ƒå±€ (Mobile) ---
                 const headerHeight = panelRect.height;
                 availableWidth = currentWidth - paddingWindowHorizontal;
                  // é«˜åº¦ = æ€»é«˜ - é¢æ¿é«˜ - é—´è· - çª—å£ç•™ç™½
                 availableHeight = currentHeight - headerHeight - LAYOUT_GAP - paddingWindowVertical;

             } else {
                 // --- å·¦å³å¸ƒå±€ (Desktop) ---
                  const panelWidth = panelRect.width;
                   // å®½åº¦ = æ€»å®½ - é¢æ¿å®½ - é—´è· - çª—å£ç•™ç™½
                  availableWidth = currentWidth - panelWidth - LAYOUT_GAP - paddingWindowHorizontal;
                  // é«˜åº¦åªå—çª—å£ç•™ç™½å½±å“
                  availableHeight = currentHeight - paddingWindowVertical;
             }

             // å‡å»æ£‹ç›˜è¾¹æ¡†å®½åº¦, å¹¶ç¡®ä¿æœ€å°å°ºå¯¸
             availableWidth = Math.max(150, availableWidth - BOARD_BORDER_WIDTH * 2);
             availableHeight = Math.max(150, availableHeight - BOARD_BORDER_WIDTH * 2);

            const cellW = availableWidth / COLS;
            const cellH = availableHeight / ROWS;
            const MAX_CELL_SIZE = 80;
            const MIN_CELL_SIZE = 25;
            let calculatedCellSize = Math.min(cellW, cellH, MAX_CELL_SIZE);
            cellSize = Math.floor(Math.max(MIN_CELL_SIZE, calculatedCellSize));
            
            margin = cellSize / 2;
            canvasWidth = cellSize * COLS;
            canvasHeight = cellSize * ROWS;
            const root = document.documentElement;
            root.style.setProperty('--cell-size', `${cellSize}px`);
            root.style.setProperty('--board-width', `${canvasWidth}px`);
            root.style.setProperty('--board-height', `${canvasHeight}px`);
            canvas.width = Math.round(canvasWidth * dpr);
            canvas.height = Math.round(canvasHeight * dpr);
            canvas.style.width = `${canvasWidth}px`;
            canvas.style.height = `${canvasHeight}px`;
            ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
        }

        function drawBoard() {
            ctx.clearRect(0, 0, canvasWidth, canvasHeight);
            ctx.fillStyle = BOARD_BG_COLOR;
            ctx.fillRect(0, 0, canvasWidth, canvasHeight);
            
            // æ²³ç•Œä½ç½®æ ¹æ®ç¿»è½¬è°ƒæ•´
            const riverY = isBoardFlipped ? 5 : 4;
            ctx.fillStyle = RIVER_BG;
            ctx.fillRect(margin, margin + riverY * cellSize, cellSize * (COLS - 1), cellSize);
            
            ctx.strokeStyle = BOARD_LINE_COLOR;
            ctx.lineWidth = Math.max(1, Math.round(cellSize * 0.025 * dpr) / dpr);
            const gridWidth = cellSize * (COLS - 1);
            const gridHeight = cellSize * (ROWS - 1);
            ctx.save();
            ctx.font = `bold ${Math.max(12, cellSize * 0.5)}px ${PIECE_FONT_FAMILY}`;
            ctx.fillStyle = RIVER_COLOR; ctx.textAlign = "center"; ctx.textBaseline = "middle";
            const riverTextY = margin + (riverY + 0.5) * cellSize;
             // æ ¹æ®å®½åº¦è°ƒæ•´æ–‡å­—
             const riverText = (cellSize < 35) ? "æ¥š æ²³ æ¼¢ ç•Œ" : "æ¥š  æ²³         æ¼¢  ç•Œ";
            ctx.fillText(riverText, margin + gridWidth / 2, riverTextY);
            ctx.restore();

            for (let i = 1; i < ROWS - 1; i++) {
                if (i == 4 || i == 5) continue;
                ctx.beginPath();
                ctx.moveTo(margin, Math.round(margin + i * cellSize));
                ctx.lineTo(margin + gridWidth, Math.round(margin + i * cellSize));
                ctx.stroke();
            }
            ctx.beginPath();
            ctx.moveTo(margin, Math.round(margin + 4 * cellSize)); ctx.lineTo(margin + gridWidth, Math.round(margin + 4 * cellSize));
            ctx.moveTo(margin, Math.round(margin + 5 * cellSize)); ctx.lineTo(margin + gridWidth, Math.round(margin + 5 * cellSize));
            ctx.stroke();
            for (let i = 1; i < COLS - 1; i++) {
                const xPos = Math.round(margin + i * cellSize);
                ctx.beginPath(); ctx.moveTo(xPos, margin); ctx.lineTo(xPos, Math.round(margin + 4 * cellSize)); ctx.stroke();
                ctx.beginPath(); ctx.moveTo(xPos, Math.round(margin + 5 * cellSize)); ctx.lineTo(xPos, margin + gridHeight); ctx.stroke();
            }
            ctx.save();
            ctx.lineWidth = Math.max(1.5, Math.round(cellSize * 0.035 * dpr) / dpr);
            ctx.strokeRect(margin - ctx.lineWidth / 2, margin - ctx.lineWidth / 2, gridWidth + ctx.lineWidth, gridHeight + ctx.lineWidth); // ç”»åœ¨å¤–å›´
            ctx.restore();

            // ç”»ä¹å®«æ ¼ï¼ˆè€ƒè™‘ç¿»è½¬ï¼‰
            if (isBoardFlipped) {
                drawCross(3, 7, 5, 9); // çº¢æ–¹ä¹å®«æ ¼ä½ç½®ç¿»è½¬
                drawCross(3, 0, 5, 2); // é»‘æ–¹ä¹å®«æ ¼ä½ç½®ç¿»è½¬
            } else {
                drawCross(3, 0, 5, 2); // é»‘æ–¹ä¹å®«æ ¼
                drawCross(3, 7, 5, 9); // çº¢æ–¹ä¹å®«æ ¼
            }
            
            const markerLineWidth = Math.max(0.8, Math.round(cellSize * 0.018 * dpr) / dpr);
            ctx.lineWidth = markerLineWidth;
            
            // ç‚®ä½æ ‡è®°ï¼ˆè€ƒè™‘ç¿»è½¬ï¼‰
            if (isBoardFlipped) {
                drawMarker(1, 7); drawMarker(7, 7); // åŸæœ¬çš„(1,2)å’Œ(7,2)
                drawMarker(1, 2); drawMarker(7, 2); // åŸæœ¬çš„(1,7)å’Œ(7,7)
            } else {
                drawMarker(1, 2); drawMarker(7, 2);
                drawMarker(1, 7); drawMarker(7, 7);
            }
            
            // å…µä½æ ‡è®°
            for (let i = 0; i <= 8; i += 2) {
                if (isBoardFlipped) {
                    drawMarker(i, 6, i > 0, i < COLS - 1); // åŸæœ¬çš„3è¡Œ
                    drawMarker(i, 3, i > 0, i < COLS - 1); // åŸæœ¬çš„6è¡Œ
                } else {
                    drawMarker(i, 3, i > 0, i < COLS - 1);
                    drawMarker(i, 6, i > 0, i < COLS - 1);
                }
            }
        }
        function drawCross(x1, y1, x2, y2) {
            ctx.beginPath();
            ctx.moveTo(margin + x1 * cellSize, margin + y1 * cellSize); ctx.lineTo(margin + x2 * cellSize, margin + y2 * cellSize);
            ctx.moveTo(margin + x2 * cellSize, margin + y1 * cellSize); ctx.lineTo(margin + x1 * cellSize, margin + y2 * cellSize);
            ctx.stroke();
        }
        function drawMarker(x, y, drawLeft = true, drawRight = true) {
            const len = cellSize / 5.5; const gap = cellSize / 8;
            const cx = margin + x * cellSize; const cy = margin + y * cellSize;
            if (drawLeft && x > 0 && y > 0) drawCorner(cx, cy, -1, -1, gap, len);
            if (drawRight && x < COLS - 1 && y > 0) drawCorner(cx, cy, 1, -1, gap, len);
            if (drawLeft && x > 0 && y < ROWS - 1) drawCorner(cx, cy, -1, 1, gap, len);
            if (drawRight && x < COLS - 1 && y < ROWS - 1) drawCorner(cx, cy, 1, 1, gap, len);
        }
        function drawCorner(cx, cy, dx, dy, gap, len) {
            ctx.beginPath();
            ctx.moveTo(cx + dx * gap, cy + dy * gap); ctx.lineTo(cx + dx * (gap + len), cy + dy * gap);
            ctx.moveTo(cx + dx * gap, cy + dy * gap); ctx.lineTo(cx + dx * gap, cy + dy * (gap + len));
            ctx.stroke();
        }

        function refreshBoard() {
           // infoPanel.getBoundingClientRect(); // Moved to setupBoardDimensions
            setupBoardDimensions();
            drawBoard();
            render();
        }

        function render() {
            piecesLayer.innerHTML = '';
            if (lastMove) {
                const fromPos = getVisualCoords(lastMove.fromX, lastMove.fromY);
                if (isValidCoord(fromPos.x, fromPos.y)) {
                    const indicator = document.createElement('div');
                    indicator.className = 'last-move-indicator';
                    indicator.style.left = `${margin + fromPos.x * cellSize}px`;
                    indicator.style.top = `${margin + fromPos.y * cellSize}px`;
                    piecesLayer.appendChild(indicator);
                }
                const toPos = getVisualCoords(lastMove.toX, lastMove.toY);
                if (isValidCoord(toPos.x, toPos.y)) {
                    const indicator = document.createElement('div');
                    indicator.className = 'last-move-indicator to-indicator';
                    indicator.style.left = `${margin + toPos.x * cellSize}px`;
                    indicator.style.top = `${margin + toPos.y * cellSize}px`;
                    piecesLayer.appendChild(indicator);
                }
            }
            if (!isAiThinking && !(gameMode !== 'PVP' && currentPlayer === aiColor)) {
                possibleMoves.forEach(move => {
                    const visualPos = getVisualCoords(move.x, move.y);
                    if (isEmpty(move.x, move.y)) {
                        const dot = document.createElement('div');
                        dot.classList.add('highlight-dot');
                        dot.style.left = `${margin + visualPos.x * cellSize}px`;
                        dot.style.top = `${margin + visualPos.y * cellSize}px`;
                        dot.onclick = (event) => {
                            event.stopPropagation();
                            handleClick(move.x, move.y);
                        };
                        piecesLayer.appendChild(dot);
                    }
                });
            }

            for (let y = 0; y < ROWS; y++) {
                for (let x = 0; x < COLS; x++) {
                    const pieceCode = boardData[y][x];
                    if (pieceCode) {
                        const visualPos = getVisualCoords(x, y);
                        const pieceDiv = document.createElement('div');
                        pieceDiv.className = `piece ${COLOR_MAP[pieceCode[0]]}`;
                        pieceDiv.textContent = PIECE_MAP[pieceCode];
                        pieceDiv.style.left = `${margin + visualPos.x * cellSize}px`;
                        pieceDiv.style.top = `${margin + visualPos.y * cellSize}px`;
                        if (!isAiThinking && !(gameMode !== 'PVP' && currentPlayer === aiColor)) {
                            if (selectedPiece && selectedPiece.x === x && selectedPiece.y === y) {
                                pieceDiv.classList.add('selected');
                            }
                            if (possibleMoves.some(move => move.x === x && move.y === y)) {
                                pieceDiv.classList.add('possible-capture');
                            }
                        }
                        pieceDiv.onclick = (event) => {
                            event.stopPropagation();
                            handleClick(x, y);
                        };
                        piecesLayer.appendChild(pieceDiv);
                    }
                }
            }
            updateInfo();
        }

        function updateInfo() {
            infoDiv.classList.remove('info-check', 'info-ai');
            if (isGameOver) return;

            if (isAiThinking) {
                infoDiv.innerHTML = `â³ AI (${COLOR_NAME[aiColor]})<br>æ€è€ƒä¸­...`; // æ¢è¡Œ
                infoDiv.style.color = INFO_AI_COLOR;
                 infoDiv.classList.add('info-ai');
                return;
            }

            let checkMsg = "";
            infoDiv.style.color = currentPlayer === 'red' ? RED_COLOR : BLACK_COLOR;

            if (isGeneralInCheck(currentPlayer, boardData)) {
                checkMsg = " - å°†å†›!";
                infoDiv.classList.add('info-check');
                const allMoves = getAllPossibleMoves(currentPlayer, boardData, redGeneralPos, blackGeneralPos);
                if (allMoves.length === 0) {
                    isGameOver = true;
                    const winner = currentPlayer === 'red' ? 'black' : 'red';
                    infoDiv.textContent = `${COLOR_NAME[winner]} è·èƒœ (å°†æ­»)! ğŸ‰`;
                    infoDiv.style.color = winner === 'red' ? RED_COLOR : BLACK_COLOR;
                    return;
                }
            }
            let playerType = "";
            if (gameMode !== 'PVP' && currentPlayer === aiColor) {
                playerType = " (AI)";
            }
            infoDiv.textContent = `å½“å‰: ${COLOR_NAME[currentPlayer]}${playerType}${checkMsg}`;
        }

        function initGame() {
            boardData = copyBoard(INITIAL_BOARD);
            currentPlayer = 'red'; selectedPiece = null; possibleMoves = [];
            isGameOver = false; lastMove = null; isAiThinking = false;
            redGeneralPos = { x: 4, y: 9 }; blackGeneralPos = { x: 4, y: 0 };
            moveHistory = []; // Reset move history
            killerMoves = Array(10).fill(null).map(() => [null, null]); // Reset killer moves
            historyTable = {}; // Reset history table
            gameStateHistory = []; // Reset undo history
            infoDiv.style.color = RED_COLOR; infoDiv.classList.remove('info-check');
            infoDiv.textContent = 'çº¢æ–¹å…ˆè¡Œ';
            
            // ä¿å­˜åˆå§‹çŠ¶æ€
            saveGameState();
            
            refreshBoard();
            if (gameMode === 'AIVP' && currentPlayer === 'red') {
                triggerAIMove();
            }
        }

        piecesLayer.addEventListener('click', (event) => {
            if (event.target === piecesLayer && selectedPiece && !isAiThinking) {
                selectedPiece = null;
                possibleMoves = [];
                render();
            }
        });

        function handleClick(x, y) {
            if (isGameOver || isAiThinking || (gameMode !== 'PVP' && currentPlayer === aiColor)) return;

            const clickedPieceCode = getPiece(x, y);
            const clickedColor = clickedPieceCode ? COLOR_MAP[clickedPieceCode[0]] : null;

            if (selectedPiece) {
                if (possibleMoves.some(move => move.x === x && move.y === y)) {
                    movePiece(selectedPiece.x, selectedPiece.y, x, y);
                }
                else if (clickedColor === currentPlayer) {
                    if (selectedPiece.x === x && selectedPiece.y === y) {
                        selectedPiece = null; possibleMoves = [];
                    } else {
                        selectPiece(x, y, clickedPieceCode);
                    }
                } else {
                    selectedPiece = null; possibleMoves = [];
                }
            } else {
                if (clickedColor === currentPlayer) {
                    selectPiece(x, y, clickedPieceCode);
                }
            }
            render();
            if (!isGameOver && gameMode !== 'PVP' && currentPlayer === aiColor && !isAiThinking) {
                triggerAIMove();
            }
        }

        function selectPiece(x, y, pieceCode) {
            selectedPiece = { x, y, piece: pieceCode };
            const rawMoves = getRawMoves(x, y, pieceCode, boardData);
            possibleMoves = rawMoves.filter(move => isMoveLegal(x, y, move.x, move.y, copyBoard(boardData), currentPlayer, redGeneralPos, blackGeneralPos)); // AI needs copy
        }

        function saveGameState() {
            // ä¿å­˜å½“å‰æ¸¸æˆçŠ¶æ€
            const state = {
                boardData: copyBoard(boardData),
                currentPlayer: currentPlayer,
                redGeneralPos: { ...redGeneralPos },
                blackGeneralPos: { ...blackGeneralPos },
                lastMove: lastMove ? { ...lastMove } : null,
                moveHistory: [...moveHistory],
                isGameOver: isGameOver
            };
            gameStateHistory.push(state);
            
            // é™åˆ¶å†å²è®°å½•é•¿åº¦ï¼Œé¿å…å†…å­˜è¿‡å¤§
            if (gameStateHistory.length > 100) {
                gameStateHistory.shift();
            }
        }
        
        function undoMove() {
            if (isAiThinking || gameStateHistory.length === 0) return;
            
            // äººæœºå¯¹æˆ˜æ¨¡å¼ä¸‹ï¼Œéœ€è¦æ’¤å›ä¸¤æ­¥ï¼ˆAIå’Œç©å®¶çš„ï¼‰
            let undoSteps = 1;
            if (gameMode !== 'PVP' && gameStateHistory.length > 1) {
                // æ£€æŸ¥ä¸Šä¸€æ­¥æ˜¯å¦æ˜¯AIèµ°çš„
                const lastState = gameStateHistory[gameStateHistory.length - 1];
                if (lastState.currentPlayer !== aiColor) {
                    undoSteps = 2; // æ’¤å›AIå’Œç©å®¶çš„ä¸¤æ­¥
                }
            }
            
            // æ‰§è¡Œæ’¤å›
            for (let i = 0; i < undoSteps && gameStateHistory.length > 0; i++) {
                gameStateHistory.pop();
            }
            
            if (gameStateHistory.length > 0) {
                // æ¢å¤åˆ°ä¹‹å‰çš„çŠ¶æ€
                const previousState = gameStateHistory[gameStateHistory.length - 1];
                boardData = copyBoard(previousState.boardData);
                currentPlayer = previousState.currentPlayer;
                redGeneralPos = { ...previousState.redGeneralPos };
                blackGeneralPos = { ...previousState.blackGeneralPos };
                lastMove = previousState.lastMove ? { ...previousState.lastMove } : null;
                moveHistory = [...previousState.moveHistory];
                isGameOver = previousState.isGameOver;
                
                selectedPiece = null;
                possibleMoves = [];
                render();
            } else {
                // å¦‚æœæ²¡æœ‰å†å²è®°å½•äº†ï¼Œé‡æ–°å¼€å§‹
                initGame();
            }
        }
        
        function movePiece(fromX, fromY, toX, toY) {
            // åœ¨ç§»åŠ¨å‰ä¿å­˜çŠ¶æ€
            saveGameState();
            
            const movingPiece = boardData[fromY][fromX];
            const targetPiece = boardData[toY][toX];
            lastMove = { fromX, fromY, toX, toY };
            boardData[toY][toX] = movingPiece;
            boardData[fromY][fromX] = null;
            
            // æ›´æ–°å°†å¸…ä½ç½®ï¼ˆå¦‚æœç§»åŠ¨çš„æ˜¯å°†å¸…ï¼‰
            if (movingPiece && movingPiece[1] === 'G') {
                const color = movingPiece[0] === 'r' ? 'red' : 'black';
                if (color === 'red') redGeneralPos = { x: toX, y: toY };
                else blackGeneralPos = { x: toX, y: toY };
            }
            
            // æ£€æŸ¥è¿™æ­¥æ£‹æ˜¯å¦é€ æˆå°†å†›
            const movingColor = movingPiece[0] === 'r' ? 'red' : 'black';
            const opponentColor = movingColor === 'red' ? 'black' : 'red';
            const causesCheck = isGeneralInCheck(opponentColor, boardData, redGeneralPos, blackGeneralPos);
            
            // Track move history with check information
            moveHistory.push({ 
                fromX, fromY, toX, toY, 
                piece: movingPiece,
                causesCheck: causesCheck
            });
            if (targetPiece && targetPiece[1] === 'G') {
                isGameOver = true;
                const winnerColor = movingPiece[0] === 'r' ? 'red' : 'black';
                infoDiv.textContent = `${COLOR_NAME[winnerColor]} è·èƒœ! ğŸ‰`;
                infoDiv.style.color = winnerColor === 'red' ? RED_COLOR : BLACK_COLOR;
                infoDiv.classList.remove('info-check');
            }
            selectedPiece = null;
            possibleMoves = [];
            if (!isGameOver) {
                currentPlayer = (currentPlayer === 'red' ? 'black' : 'red');
            }
        }

        function isMoveLegal(fromX, fromY, toX, toY, currentBoard, color, rG, bG) {
            const movingPiece = currentBoard[fromY][fromX];
            if (!movingPiece) return false;
            const originalTarget = currentBoard[toY][toX];
            let tempRedG = { ...rG };
            let tempBlackG = { ...bG };
            currentBoard[toY][toX] = movingPiece;
            currentBoard[fromY][fromX] = null;
            if (movingPiece === 'rG') tempRedG = { x: toX, y: toY };
            if (movingPiece === 'bG') tempBlackG = { x: toX, y: toY };
            const isInCheck = isGeneralInCheck(color, currentBoard, tempRedG, tempBlackG);
             // No need to restore for AI virtual board copy, but good practice if board was passed by ref
            // currentBoard[fromY][fromX] = movingPiece;
            // currentBoard[toY][toX] = originalTarget;
            return !isInCheck;
        }
       
        function isGeneralInCheck(color, board, rG = redGeneralPos, bG = blackGeneralPos) {
            const myGeneralPos = color === 'red' ? rG : bG;
            const opponentColorChar = color === 'red' ? 'b' : 'r';
            const opponentGeneralPos = color === 'red' ? bG : rG;
            if (!myGeneralPos || !opponentGeneralPos || !getPiece(myGeneralPos.x, myGeneralPos.y, board) || !getPiece(opponentGeneralPos.x, opponentGeneralPos.y, board)) return false;
            if (myGeneralPos.x === opponentGeneralPos.x) {
                let clearPath = true;
                const minY = Math.min(myGeneralPos.y, opponentGeneralPos.y); const maxY = Math.max(myGeneralPos.y, opponentGeneralPos.y);
                for (let y = minY + 1; y < maxY; y++) { if (board[y][myGeneralPos.x] !== null) { clearPath = false; break; } }
                if (clearPath) return true;
            }
            for (let y = 0; y < ROWS; y++) {
                for (let x = 0; x < COLS; x++) {
                    const piece = board[y][x];
                    if (piece && piece[0] === opponentColorChar && piece[1] !== 'G') {
                        const opponentMoves = getRawMoves(x, y, piece, board);
                        if (opponentMoves.some(move => move.x === myGeneralPos.x && move.y === myGeneralPos.y)) { return true; }
                    }
                }
            }
            return false;
        }

        function getRawMoves(x, y, pieceCode, board) { let moves = []; if (!pieceCode) return moves; const color = pieceCode[0]; const type = pieceCode[1]; const targetColor = COLOR_MAP[color]; const addMove = (nx, ny) => { if (!isValidCoord(nx, ny)) return false; const target = getPiece(nx, ny, board); if (!target) { moves.push({ x: nx, y: ny }); return true; } else if (target[0] !== color) { moves.push({ x: nx, y: ny }); return false; } return false; }; const checkAndAdd = (nx, ny) => { if (isValidCoord(nx, ny) && !isAlly(nx, ny, targetColor, board)) { moves.push({ x: nx, y: ny }); } }; switch (type) { case 'R': const directions = [[0, -1], [0, 1], [-1, 0], [1, 0]]; directions.forEach(([dx, dy]) => { for (let i = 1; i < Math.max(ROWS, COLS); i++) { const nx = x + i * dx, ny = y + i * dy; if (!isValidCoord(nx, ny) || !addMove(nx, ny)) break; } }); break; case 'C': const dirs = [[0, -1], [0, 1], [-1, 0], [1, 0]]; dirs.forEach(([dx, dy]) => { let hasMount = false; for (let i = 1; i < Math.max(ROWS, COLS); i++) { const nx = x + i * dx; const ny = y + i * dy; if (!isValidCoord(nx, ny)) break; const target = getPiece(nx, ny, board); if (!hasMount) { if (!target) moves.push({ x: nx, y: ny }); else hasMount = true; } else { if (target) { if (target[0] !== color) moves.push({ x: nx, y: ny }); break; } } } }); break; case 'H': const horseSteps = [{ move: [1, 2], leg: [0, 1] }, { move: [1, -2], leg: [0, -1] }, { move: [-1, 2], leg: [0, 1] }, { move: [-1, -2], leg: [0, -1] }, { move: [2, 1], leg: [1, 0] }, { move: [2, -1], leg: [1, 0] }, { move: [-2, 1], leg: [-1, 0] }, { move: [-2, -1], leg: [-1, 0] }]; horseSteps.forEach(({ move, leg }) => { const legX = x + leg[0], legY = y + leg[1]; if (isValidCoord(legX, legY) && isEmpty(legX, legY, board)) { checkAndAdd(x + move[0], y + move[1]); } }); break; case 'E': const eleSteps = [{ move: [2, 2], eye: [1, 1] }, { move: [2, -2], eye: [1, -1] }, { move: [-2, 2], eye: [-1, 1] }, { move: [-2, -2], eye: [-1, -1] }]; eleSteps.forEach(({ move, eye }) => { const nx = x + move[0], ny = y + move[1]; if ((color === 'r' && !isRedSide(ny)) || (color === 'b' && !isBlackSide(ny))) return; if (!isValidCoord(nx, ny)) return; const eyeX = x + eye[0], eyeY = y + eye[1]; if (isValidCoord(eyeX, eyeY) && isEmpty(eyeX, eyeY, board)) { checkAndAdd(nx, ny); } }); break; case 'A': const advMoves = [[1, 1], [1, -1], [-1, 1], [-1, -1]]; advMoves.forEach(([dx, dy]) => { const nx = x + dx, ny = y + dy; const inPalace = (color === 'r' && isRedPalace(nx, ny)) || (color === 'b' && isBlackPalace(nx, ny)); if (inPalace) checkAndAdd(nx, ny); }); break; case 'G': const genMoves = [[0, 1], [0, -1], [1, 0], [-1, 0]]; genMoves.forEach(([dx, dy]) => { const nx = x + dx, ny = y + dy; const inPalace = (color === 'r' && isRedPalace(nx, ny)) || (color === 'b' && isBlackPalace(nx, ny)); if (inPalace) checkAndAdd(nx, ny); }); break; case 'S': if (color === 'r') { checkAndAdd(x, y - 1); if (!isRedSide(y)) { checkAndAdd(x - 1, y); checkAndAdd(x + 1, y); } } else { checkAndAdd(x, y + 1); if (!isBlackSide(y)) { checkAndAdd(x - 1, y); checkAndAdd(x + 1, y); } } break; } return moves; }

        // ================== AI LOGIC START ==================
        
        // åˆ¤æ–­æ¸¸æˆé˜¶æ®µ
        function getGamePhase(board) {
            // è®¡ç®—å›åˆæ•°
            const totalMoves = moveHistory.length;
            if (totalMoves < 20) { // å‰10ä¸ªå›åˆï¼ˆæ¯æ–¹10æ­¥ï¼‰
                return 'opening';
            }
            
            // è®¡ç®—åŒæ–¹å¤§å­æ•°é‡
            let redMajorPieces = 0;
            let blackMajorPieces = 0;
            
            for (let y = 0; y < ROWS; y++) {
                for (let x = 0; x < COLS; x++) {
                    const piece = board[y][x];
                    if (!piece) continue;
                    const type = piece[1];
                    if (type === 'R' || type === 'H' || type === 'C') {
                        if (piece[0] === 'r') {
                            redMajorPieces++;
                        } else {
                            blackMajorPieces++;
                        }
                    }
                }
            }
            
            // å¦‚æœåŒæ–¹å¤§å­éƒ½å°‘äº3ä¸ªï¼Œè¿›å…¥æ®‹å±€
            if (redMajorPieces < 3 && blackMajorPieces < 3) {
                return 'endgame';
            }
            
            return 'midgame';
        }
        
        // è·å–æ£‹å­ä»·å€¼
        function getPieceValue(type, x, y, colorChar, gamePhase) {
            let baseValue = 0;
            
            // æ ¹æ®æ¸¸æˆé˜¶æ®µé€‰æ‹©åŸºç¡€ä»·å€¼
            switch (gamePhase) {
                case 'opening':
                    baseValue = OPENING_VALUES[type] || 0;
                    // å¼€å±€é˜¶æ®µå…µçš„ç‰¹æ®Šä»·å€¼
                    if (type === 'S') {
                        if (x === 0 || x === 8) {
                            baseValue = 100; // è¾¹å…µ
                        } else if (x === 2 || x === 6) {
                            baseValue = 130; // 3è·¯å’Œ7è·¯å…µ
                        } else if (x === 4) {
                            baseValue = 160; // ä¸­å…µ
                        }
                    }
                    break;
                case 'midgame':
                    baseValue = MIDGAME_VALUES[type] || 0;
                    break;
                case 'endgame':
                    baseValue = ENDGAME_VALUES[type] || 0;
                    break;
            }
            
            return baseValue;
        }
        
        // è®¡ç®—å£«è±¡å®Œæ•´å¥–åŠ±
        function getAdvisorElephantBonus(board, colorChar, gamePhase) {
            let advisorCount = 0;
            let elephantCount = 0;
            
            for (let y = 0; y < ROWS; y++) {
                for (let x = 0; x < COLS; x++) {
                    const piece = board[y][x];
                    if (piece && piece[0] === colorChar) {
                        if (piece[1] === 'A') advisorCount++;
                        if (piece[1] === 'E') elephantCount++;
                    }
                }
            }
            
            // ä¸­å±€é˜¶æ®µï¼šå£«è±¡éƒ½å®Œæ•´æœ‰100åˆ†å¥–åŠ±
            if (gamePhase === 'midgame' && advisorCount === 2 && elephantCount === 2) {
                return 100;
            }
            
            return 0;
        }
        
        // æ£€æŸ¥è¿ç»­å°†å†›æ¬¡æ•°
        function checkContinuousChecks(colorChar) {
            if (moveHistory.length < 8) return 0;
            
            let continuousCount = 0;
            let lastPiece = null;
            let lastFromX = -1;
            let lastFromY = -1;
            
            // ä»æœ€è¿‘çš„ç§»åŠ¨å¼€å§‹å‘å‰æ£€æŸ¥
            for (let i = moveHistory.length - 1; i >= 0 && i >= moveHistory.length - 16; i--) {
                const move = moveHistory[i];
                if (!move.piece || move.piece[0] !== colorChar) {
                    break; // ä¸æ˜¯è¯¥é¢œè‰²çš„æ£‹å­ï¼Œä¸­æ–­
                }
                
                if (move.causesCheck) {
                    // æ£€æŸ¥æ˜¯å¦æ˜¯åŒä¸€ä¸ªæ£‹å­è¿ç»­å°†å†›
                    if (lastPiece === null || 
                        (move.piece === lastPiece && 
                         move.toX === lastFromX && 
                         move.toY === lastFromY)) {
                        continuousCount++;
                        lastPiece = move.piece;
                        lastFromX = move.fromX;
                        lastFromY = move.fromY;
                    } else {
                        break; // ä¸æ˜¯åŒä¸€ä¸ªæ£‹å­ï¼Œä¸­æ–­
                    }
                } else {
                    break; // æ²¡æœ‰å°†å†›ï¼Œä¸­æ–­
                }
            }
            
            return continuousCount;
        }
        
        function evaluateBoard(board, rG, bG) {
            let score = 0;
            if (!getPiece(rG.x, rG.y, board)) return -50000;
            if (!getPiece(bG.x, bG.y, board)) return 50000;
            
            // æ£€æŸ¥é•¿å°†æƒ©ç½š
            const redContinuousChecks = checkContinuousChecks('r');
            const blackContinuousChecks = checkContinuousChecks('b');
            
            // é•¿å°†æƒ©ç½šæœºåˆ¶ï¼š1-4æ¬¡ä¸æƒ©ç½šï¼Œ5-7æ¬¡é€’å¢æƒ©ç½šï¼Œ8æ¬¡åˆ¤è´Ÿ
            function getCheckPenalty(checkCount) {
                if (checkCount <= 4) return 0;        // 1-4æ¬¡ä¸æƒ©ç½š
                if (checkCount === 5) return 500;     // ç¬¬5æ¬¡æƒ©ç½š500åˆ†
                if (checkCount === 6) return 2000;    // ç¬¬6æ¬¡æƒ©ç½š2000åˆ†
                if (checkCount === 7) return 5000;    // ç¬¬7æ¬¡æƒ©ç½š5000åˆ†
                if (checkCount >= 8) return 20000;    // 8æ¬¡æˆ–ä»¥ä¸Šåˆ¤è´Ÿ
                return 0;
            }
            
            score -= getCheckPenalty(redContinuousChecks);
            score += getCheckPenalty(blackContinuousChecks);
            
            // è·å–å½“å‰æ¸¸æˆé˜¶æ®µ
            const gamePhase = getGamePhase(board);
            
            // Material and position evaluation
            for (let y = 0; y < ROWS; y++) {
                for (let x = 0; x < COLS; x++) {
                    const piece = board[y][x];
                    if (!piece) continue;
                    const colorChar = piece[0];
                    const type = piece[1];
                    
                    // è·å–åŸºäºæ¸¸æˆé˜¶æ®µçš„æ£‹å­ä»·å€¼
                    let pieceValue = getPieceValue(type, x, y, colorChar, gamePhase);
                    
                    // Add position value
                    if (POSITION_VALUES[type]) {
                        const posY = colorChar === 'r' ? y : (9 - y);
                        const posValue = POSITION_VALUES[type][posY][x];
                        pieceValue += posValue;
                    }
                    
                    // Special bonuses for soldiers
                    if (type === 'S') {
                        if (colorChar === 'r' && !isRedSide(y)) {
                            pieceValue += SOLDIER_CROSS_RIVER_BONUS + (4 - y) * 5;
                            if (x >= 3 && x <= 5) pieceValue += 15; // Center file bonus
                        }
                        if (colorChar === 'b' && !isBlackSide(y)) {
                            pieceValue += SOLDIER_CROSS_RIVER_BONUS + (y - 5) * 5;
                            if (x >= 3 && x <= 5) pieceValue += 15;
                        }
                    }
                    
                    // Mobility bonus (simple version)
                    if (type === 'R' || type === 'H' || type === 'C') {
                        const moves = getRawMoves(x, y, piece, board);
                        pieceValue += moves.length * 2; // 2 points per legal move
                    }
                    
                    // King safety penalty if exposed
                    if (type === 'G') {
                        const enemyChar = colorChar === 'r' ? 'b' : 'r';
                        let threats = 0;
                        for (let ty = 0; ty < ROWS; ty++) {
                            for (let tx = 0; tx < COLS; tx++) {
                                const enemyPiece = board[ty][tx];
                                if (enemyPiece && enemyPiece[0] === enemyChar) {
                                    const enemyMoves = getRawMoves(tx, ty, enemyPiece, board);
                                    if (enemyMoves.some(m => m.x === x && m.y === y)) {
                                        threats++;
                                    }
                                }
                            }
                        }
                        pieceValue -= threats * 50;
                    }
                    
                    if (colorChar === 'r') {
                        score += pieceValue;
                    } else {
                        score -= pieceValue;
                    }
                }
            }
            
            // æ·»åŠ å£«è±¡å®Œæ•´å¥–åŠ±
            score += getAdvisorElephantBonus(board, 'r', gamePhase);
            score -= getAdvisorElephantBonus(board, 'b', gamePhase);
            
            // Endgame adjustments
            const pieceCount = board.flat().filter(p => p !== null).length;
            if (pieceCount < 16) { // Endgame
                // Centralize king in endgame
                const rKingCenterDist = Math.abs(rG.x - 4) + Math.abs(rG.y - 8);
                const bKingCenterDist = Math.abs(bG.x - 4) + Math.abs(bG.y - 1);
                score += (bKingCenterDist - rKingCenterDist) * 10;
            }
            
            return score;
        }
        function getAllPossibleMoves(color, board, rG, bG) {
            const moves = [];
            const colorChar = color[0];
            for (let y = 0; y < ROWS; y++) {
                for (let x = 0; x < COLS; x++) {
                    const piece = board[y][x];
                    if (piece && piece[0] === colorChar) {
                        const rawMoves = getRawMoves(x, y, piece, board);
                        rawMoves.forEach(move => {
                            if (isMoveLegal(x, y, move.x, move.y, copyBoard(board), color, rG, bG)) {
                                moves.push({ fromX: x, fromY: y, toX: move.x, toY: move.y });
                            }
                        });
                    }
                }
            }
            return moves;
        }
        function performVirtualMove(board, move, rG, bG) {
            const newBoard = copyBoard(board);
            const newRG = { ...rG };
            const newBG = { ...bG };
            const piece = newBoard[move.fromY][move.fromX];
             if(!piece) return { board: newBoard, rG: newRG, bG: newBG }; // Safety
            newBoard[move.toY][move.toX] = piece;
            newBoard[move.fromY][move.fromX] = null;
            if (piece === 'rG') { newRG.x = move.toX; newRG.y = move.toY;
            } else if (piece === 'bG') { newBG.x = move.toX; newBG.y = move.toY; }
            return { board: newBoard, rG: newRG, bG: newBG };
        }
        function quiescenceSearch(board, depth, alpha, beta, isMaximizing, rG, bG) {
            // Terminal node evaluation
            if (!getPiece(rG.x, rG.y, board)) return -50000;
            if (!getPiece(bG.x, bG.y, board)) return 50000;
            
            const standPat = evaluateBoard(board, rG, bG);
            
            if (depth <= 0) {
                return standPat;
            }
            
            if (isMaximizing) {
                if (standPat >= beta) return beta;
                if (alpha < standPat) alpha = standPat;
                
                // Only search capture moves
                const currentColor = 'red';
                const captureMoves = getAllCaptureMoves(currentColor, board, rG, bG);
                
                for (const move of captureMoves) {
                    const state = performVirtualMove(board, move, rG, bG);
                    const score = quiescenceSearch(state.board, depth - 1, alpha, beta, false, state.rG, state.bG);
                    if (score >= beta) return beta;
                    if (score > alpha) alpha = score;
                }
                return alpha;
            } else {
                if (standPat <= alpha) return alpha;
                if (beta > standPat) beta = standPat;
                
                // Only search capture moves
                const currentColor = 'black';
                const captureMoves = getAllCaptureMoves(currentColor, board, rG, bG);
                
                for (const move of captureMoves) {
                    const state = performVirtualMove(board, move, rG, bG);
                    const score = quiescenceSearch(state.board, depth - 1, alpha, beta, true, state.rG, state.bG);
                    if (score <= alpha) return alpha;
                    if (score < beta) beta = score;
                }
                return beta;
            }
        }
        
        function getAllCaptureMoves(color, board, rG, bG) {
            const moves = [];
            const colorChar = color[0];
            for (let y = 0; y < ROWS; y++) {
                for (let x = 0; x < COLS; x++) {
                    const piece = board[y][x];
                    if (piece && piece[0] === colorChar) {
                        const rawMoves = getRawMoves(x, y, piece, board);
                        rawMoves.forEach(move => {
                            const targetPiece = getPiece(move.x, move.y, board);
                            if (targetPiece && targetPiece[0] !== colorChar) {
                                if (isMoveLegal(x, y, move.x, move.y, copyBoard(board), color, rG, bG)) {
                                    // ä½¿ç”¨å½“å‰é˜¶æ®µçš„æ£‹å­ä»·å€¼
                                    const gamePhase = getGamePhase(board);
                                    const captureValue = getPieceValue(targetPiece[1], move.x, move.y, targetPiece[0], gamePhase);
                                    moves.push({
                                        fromX: x, fromY: y, toX: move.x, toY: move.y,
                                        captureValue: captureValue
                                    });
                                }
                            }
                        });
                    }
                }
            }
            // Sort by capture value (highest first)
            moves.sort((a, b) => b.captureValue - a.captureValue);
            return moves;
        }

        function alphaBetaSearch(board, depth, alpha, beta, isMaximizing, rG, bG) {
             // Check generals first, avoid calculating moves if one is missing
            if (!getPiece(rG.x, rG.y, board)) return -50000 - (SEARCH_DEPTH - depth)*10; // lose faster is worse
            if (!getPiece(bG.x, bG.y, board)) return 50000 + (SEARCH_DEPTH - depth)*10; // win faster is better

            if (depth === 0) {
               // Use quiescence search to avoid horizon effect
               return quiescenceSearch(board, QUIESCENCE_DEPTH, alpha, beta, isMaximizing, rG, bG);
            }
            const currentColor = isMaximizing ? 'red' : 'black';
            const possibleMoves = getAllPossibleMoves(currentColor, board, rG, bG);
            if (possibleMoves.length === 0) {
                 // Checkmate or Stalemate (treat as loss)
                return isMaximizing ? -40000 - (SEARCH_DEPTH - depth)*10 : 40000 + (SEARCH_DEPTH - depth)*10;
            }
            
            // Improved move ordering
            possibleMoves.sort((a, b) => {
                // Check killer moves
                for (let i = 0; i < 2; i++) {
                    const killer = killerMoves[depth][i];
                    if (killer) {
                        if (a.fromX === killer.fromX && a.fromY === killer.fromY &&
                            a.toX === killer.toX && a.toY === killer.toY) return -1;
                        if (b.fromX === killer.fromX && b.fromY === killer.fromY &&
                            b.toX === killer.toX && b.toY === killer.toY) return 1;
                    }
                }
                
                // History heuristic
                const keyA = `${a.fromX},${a.fromY},${a.toX},${a.toY}`;
                const keyB = `${b.fromX},${b.fromY},${b.toX},${b.toY}`;
                const histA = historyTable[keyA] || 0;
                const histB = historyTable[keyB] || 0;
                if (histA !== histB) return histB - histA;
                
                // Capture ordering
                const targetA = getPiece(a.toX, a.toY, board);
                const targetB = getPiece(b.toX, b.toY, board);
                const gamePhase = getGamePhase(board);
                const valueA = targetA ? getPieceValue(targetA[1], a.toX, a.toY, targetA[0], gamePhase) : 0;
                const valueB = targetB ? getPieceValue(targetB[1], b.toX, b.toY, targetB[0], gamePhase) : 0;
                return valueB - valueA;
            });

            if (isMaximizing) {
                let maxEval = -Infinity;
                for (const move of possibleMoves) {
                    const state = performVirtualMove(board, move, rG, bG);
                    const evaluation = alphaBetaSearch(state.board, depth - 1, alpha, beta, false, state.rG, state.bG);
                    if (evaluation > maxEval) {
                        maxEval = evaluation;
                        if (evaluation >= beta) {
                            // Update killer moves
                            if (!killerMoves[depth][0] ||
                                killerMoves[depth][0].fromX !== move.fromX ||
                                killerMoves[depth][0].fromY !== move.fromY ||
                                killerMoves[depth][0].toX !== move.toX ||
                                killerMoves[depth][0].toY !== move.toY) {
                                killerMoves[depth][1] = killerMoves[depth][0];
                                killerMoves[depth][0] = move;
                            }
                            // Update history
                            const key = `${move.fromX},${move.fromY},${move.toX},${move.toY}`;
                            historyTable[key] = (historyTable[key] || 0) + depth * depth;
                        }
                    }
                    alpha = Math.max(alpha, evaluation);
                    if (beta <= alpha) break;
                }
                return maxEval;
            } else {
                let minEval = Infinity;
                for (const move of possibleMoves) {
                    const state = performVirtualMove(board, move, rG, bG);
                    const evaluation = alphaBetaSearch(state.board, depth - 1, alpha, beta, true, state.rG, state.bG);
                    if (evaluation < minEval) {
                        minEval = evaluation;
                        if (evaluation <= alpha) {
                            // Update killer moves
                            if (!killerMoves[depth][0] ||
                                killerMoves[depth][0].fromX !== move.fromX ||
                                killerMoves[depth][0].fromY !== move.fromY ||
                                killerMoves[depth][0].toX !== move.toX ||
                                killerMoves[depth][0].toY !== move.toY) {
                                killerMoves[depth][1] = killerMoves[depth][0];
                                killerMoves[depth][0] = move;
                            }
                            // Update history
                            const key = `${move.fromX},${move.fromY},${move.toX},${move.toY}`;
                            historyTable[key] = (historyTable[key] || 0) + depth * depth;
                        }
                    }
                    beta = Math.min(beta, evaluation);
                    if (beta <= alpha) break;
                }
                return minEval;
            }
        }
        function findBestMove(board, color, rG, bG, depth) {
            console.time(`AI Thinking Depth ${depth}`);
            
            const possibleMoves = getAllPossibleMoves(color, board, rG, bG);
            if (possibleMoves.length === 0) {
                console.timeEnd(`AI Thinking Depth ${depth}`);
                return null;
            }
            let bestMove = null;
            let bestValue = color === 'red' ? -Infinity : Infinity;
            let bestMovesPool = [];
            const isMaximizing = (color === 'red');
            for (const move of possibleMoves) {
                const state = performVirtualMove(board, move, rG, bG);
                const moveValue = alphaBetaSearch(state.board, depth - 1, -Infinity, Infinity, !isMaximizing, state.rG, state.bG);
                if (isMaximizing) {
                    if (moveValue > bestValue) {
                        bestValue = moveValue;
                        bestMovesPool = [move];
                    } else if (moveValue > -Infinity && moveValue === bestValue) { // Ensure not comparing with initial -Infinity if all moves are terrible
                        bestMovesPool.push(move);
                    }
                } else {
                    if (moveValue < bestValue) {
                        bestValue = moveValue;
                        bestMovesPool = [move];
                    } else if (moveValue < Infinity && moveValue === bestValue) {
                         bestMovesPool.push(move);
                    }
                }
            }
             // Default to first move if pool is empty somehow or all values are +/-Infinity
             if(bestMovesPool.length === 0 && possibleMoves.length > 0) {
                 bestMovesPool.push(possibleMoves[0]);
             }

            if (bestMovesPool.length > 0) {
                const randomIndex = Math.floor(Math.random() * bestMovesPool.length);
                bestMove = bestMovesPool[randomIndex];
            }
            console.log(`AI (${color}) Best value:`, bestValue, "Move:", bestMove, "Pool size:", bestMovesPool.length);
            console.timeEnd(`AI Thinking Depth ${depth}`);
            return bestMove;
        }
        function triggerAIMove() {
            if (isGameOver || currentPlayer !== aiColor) return;
            isAiThinking = true;
            selectedPiece = null;
            possibleMoves = [];
            render();
            setTimeout(() => {
                const bestMove = findBestMove(boardData, aiColor, redGeneralPos, blackGeneralPos, SEARCH_DEPTH);
                isAiThinking = false;
                if (bestMove && !isGameOver) {
                    movePiece(bestMove.fromX, bestMove.fromY, bestMove.toX, bestMove.toY);
                } else {
                     if (!isGameOver) { // AI Resigns
                        isGameOver = true;
                        const winner = aiColor === 'red' ? 'black' : 'red';
                        infoDiv.textContent = `${COLOR_NAME[winner]} è·èƒœ (AIè®¤è¾“)! ğŸ‰`;
                        infoDiv.style.color = winner === 'red' ? RED_COLOR : BLACK_COLOR;
                        infoDiv.classList.remove('info-check', 'info-ai');
                    }
                }
                render();
            }, AI_DELAY);
        }
        // ================== AI LOGIC END ==================

        function updateModeAndBoard() {
            // æ ¹æ®æ¸¸æˆæ¨¡å¼å†³å®šæ˜¯å¦ç¿»è½¬æ£‹ç›˜
            // äººæœºå¯¹æˆ˜æ—¶ï¼Œå¦‚æœç”¨æˆ·æ‰§é»‘ï¼ˆAIæ‰§çº¢ï¼‰ï¼Œéœ€è¦ç¿»è½¬æ£‹ç›˜è®©ç”¨æˆ·åœ¨ä¸‹æ–¹
            if (gameMode === 'PVAI' && aiColor === 'red') {
                isBoardFlipped = true;
            } else {
                // å…¶ä»–æ‰€æœ‰æƒ…å†µéƒ½ä¸ç¿»è½¬
                // PVPæ¨¡å¼ï¼šä¸ç¿»è½¬
                // PVAIä¸”AIæ‰§é»‘ï¼šç”¨æˆ·æ‰§çº¢åœ¨ä¸‹æ–¹ï¼Œä¸éœ€è¦ç¿»è½¬
                // AIVPæ¨¡å¼ï¼šAIå…ˆæ‰‹ä½†ç”¨æˆ·è¿˜æ˜¯åœ¨æ­£ç¡®çš„ä½ç½®ï¼Œä¸éœ€è¦ç¿»è½¬
                isBoardFlipped = false;
            }
        }
        
        function updateModeButtonText() {
            if (gameMode === 'PVP') modeButton.textContent = "æ¨¡å¼: ğŸ‘¤ vs ğŸ‘¤";
            if (gameMode === 'PVAI') modeButton.textContent = `æ¨¡å¼: ğŸ‘¤ vs ğŸ’»(${COLOR_NAME[aiColor]})`;
            if (gameMode === 'AIVP') modeButton.textContent = `æ¨¡å¼: ğŸ’»(${COLOR_NAME[aiColor]}) vs ğŸ‘¤`;
        }
        modeButton.addEventListener('click', () => {
            if (isAiThinking) return;
            if (gameMode === 'PVP') {
                gameMode = 'PVAI';
                aiColor = 'black';
            } else if (gameMode === 'PVAI' && aiColor === 'black') {
                // åˆ‡æ¢åˆ°ç”¨æˆ·æ‰§é»‘ï¼ŒAIæ‰§çº¢
                gameMode = 'PVAI';
                aiColor = 'red';
            } else if (gameMode === 'PVAI' && aiColor === 'red') {
                gameMode = 'AIVP';
                aiColor = 'red';
            } else {
                gameMode = 'PVP';
                aiColor = '';
            }
            updateModeButtonText();
            updateModeAndBoard();
            initGame();
        });
      
        function isCurrentlyFullscreen() {
            return document.fullscreenElement || document.webkitFullscreenElement || document.mozFullScreenElement || document.msFullscreenElement;
        }
        function updateButtonState(event) {
            const isActualChange = !!event;
            if (!fullscreenButton) return;
            if (isCurrentlyFullscreen()) {
                fullscreenButton.textContent = 'â›¶';
                fullscreenButton.title = 'é€€å‡ºå…¨å±';
                document.body.style.overflow = 'hidden';
                 document.body.style.padding = '0';
            } else {
                fullscreenButton.textContent = 'â›¶';
                fullscreenButton.title = 'è¿›å…¥å…¨å±';
                document.body.style.overflowX = 'hidden';
                document.body.style.overflowY = 'auto';
                 document.body.style.paddingTop = '15px';
                 document.body.style.paddingBottom = '15px';
            }
            if (isActualChange) {
                clearTimeout(resizeDebounceTimer);
                // å»¶è¿Ÿæ›´é•¿ä¸€ç‚¹ï¼Œç¡®ä¿å¸ƒå±€åˆ‡æ¢å®Œæˆ
                resizeDebounceTimer = setTimeout(refreshBoard, 250);
            }
        }
        function toggleFullscreen() {
            // å…¨å± wrapper è€Œä¸æ˜¯æ•´ä¸ª documentï¼Œæ•ˆæœæ›´å¥½
            const elementToFullscreen = gameWrapper; // document.documentElement;
            const doc = document;
            if (!isCurrentlyFullscreen()) {
                 if (elementToFullscreen.requestFullscreen) { elementToFullscreen.requestFullscreen().catch(err => console.warn(err));
                } else if (elementToFullscreen.mozRequestFullScreen) { elementToFullscreen.mozRequestFullScreen();
                 } else if (elementToFullscreen.webkitRequestFullscreen) { elementToFullscreen.webkitRequestFullscreen(Element.ALLOW_KEYBOARD_INPUT);
                 } else if (elementToFullscreen.msRequestFullscreen) { elementToFullscreen.msRequestFullscreen(); }
                 // Also fullscreen body for background color safari
                 document.documentElement.webkitRequestFullscreen && document.documentElement.webkitRequestFullscreen();

            } else {
                if (doc.exitFullscreen) { doc.exitFullscreen().catch(err => console.warn(err));
                } else if (doc.mozCancelFullScreen) { doc.mozCancelFullScreen();
                } else if (doc.webkitExitFullscreen) { doc.webkitExitFullscreen();
                } else if (doc.msExitFullscreen) { doc.msExitFullscreen(); }
            }
        }
        const isFullscreenAPISupported = document.fullscreenEnabled || document.webkitFullscreenEnabled || document.mozFullScreenEnabled || document.msFullscreenEnabled;
        if (fullscreenButton && isFullscreenAPISupported) {
            fullscreenButton.style.display = 'inline-block';
            fullscreenButton.addEventListener('click', toggleFullscreen);
            document.addEventListener('fullscreenchange', updateButtonState);
            document.addEventListener('webkitfullscreenchange', updateButtonState);
            document.addEventListener('mozfullscreenchange', updateButtonState);
            document.addEventListener('MSFullscreenChange', updateButtonState);
        } else if (fullscreenButton) {
            fullscreenButton.style.display = 'none';
        }
    
        resetButton.addEventListener('click', () => {
            if (isAiThinking) return;
            initGame();
        });
        
        undoButton.addEventListener('click', () => {
            undoMove();
        });

        window.addEventListener('resize', () => {
           // if (isCurrentlyFullscreen()) return; // å…¨å±åˆ‡æ¢ç”± fullscreenchange äº‹ä»¶å¤„ç†, ä½†resizeä¹Ÿä¼šè§¦å‘ï¼Œä¿ç•™å¹¶ç”¨debounce
            clearTimeout(resizeDebounceTimer);
            resizeDebounceTimer = setTimeout(refreshBoard, 150);
        });

        document.addEventListener('DOMContentLoaded', () => {
            updateModeButtonText();
            updateModeAndBoard();
            initGame();
        });

        window.addEventListener('load', () => {
             // load ä¹‹åå¸ƒå±€ç¨³å®šï¼Œå†åˆ·æ–°ä¸€æ¬¡ç¡®ä¿å°ºå¯¸æ­£ç¡®ï¼Œç‰¹åˆ«æ˜¯å­—ä½“åŠ è½½å
             refreshBoard();
             updateButtonState(null);
        });

    </script>

</body>

</html>
